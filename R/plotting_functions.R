### Plotting functions. The plotting functions here include: arbin_quickplot,
### for quickly plotting any x or y variable; arbin_plotvp, for plotting voltage
### vs capacity profiles of one or more cycles of one cell; arbin_qplot, for plotting
### capacity vs cycle number with multiple datasets;arbin_dQdV, for plotting
### differential capacity plot of one or multiple cycles of one cell;arbin_dQdV_multi,
### for plotting differential capacity plot of multiple cells at one cycle number.

#' arbin_quickplot
#'
#' This function takes a data frame of either raw data or aggregated statistics,
#' any argument for x or y-axis plotting, and returns a ggplot with the desired
#' formatting and axis labels. Can also do things such as subsetting data with
#' dplyr.
#' @param data The dataset, which must be a list generated by arbinimport.
#' @param x The variable to be plotted on the x-axis
#' @param y The variable to be plotted on the y-axis
#' @param norm character string used to select how to normalize your data: "mass", "area", "vol".
#' @param geom The geom to be passed to ggplot; e.g. geom_point or geom_path
#' @param size The size of the geom.
#' @keywords
#' @export
#' @examples
#' arbin_quickplot(list, x = t, y = E)
#' arbin_quickplot(list, x = t, y = E, norm="mass", geom = geom_path, size = 1)
#' arbin_quickplot(list, x = cyc.n, y = d.Q, norm="area")

arbin_quickplot<- function (l, x="cyc.n", y="Q.d", norm=NULL, geom = geom_point, size = 4) {
  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)

  #decide whether we need raw or stats to pull from l
  #If x axis is time, or capacity need to pull raw data
  if (x=="t" | x=="Q.d" |x=="Q.c"){
    data<-l$raw
  }
  #If x axis is cycle pull stats
  if (x=="cyc.n"){
    data<-l$stats
  }

  #Set units depending on normalization desired============================
  # labels is a list of labels with the element names corresponding to
  # variable names present in the data files. When plotting, a correctly
  # formatted axis label is selected from the list.

  #set units for no normalization========================================
  labels<-NULL
  if (is.null(norm)){
    labels <- list(
      t = "time / s",
      step.n = "step number",
      cyc.n = "cycle number",
      I = "I / A",
      E = "cell voltage / V",
      Q.c = "Q charge / mAh",
      Q.d = "Q discharge / mAh",
      step.t = "step time / s",
      En.d = "discharge energy / Wh",
      En.c = "charge energy / Wh",
      CE = expression("Q"[d] * " / Q"[c]),
      EE = expression("energy efficiency, E"[d] * " / E"[c]),
      meanE.d = "mean discharge voltage / V",
      meanE.c = "mean charge voltage / V")
  }
  #if normalization is used then set the proper labels
  if (!is.null(norm))
#set units for mass normalization
  {if (norm=="mass" & !is.null(l$norm$mass)){
    labels <- list(
      t = "time / s",
      step.n = "step number",
      cyc.n = "cycle number",
      I = "I / A",
      E = "cell voltage / V",
      Q.c = "Q charge / mAh g"^-1 ~ "",
      Q.d = "Q discharge / mAh g"^-1 ~ "",
      step.t = "step time / s",
      En.d = "discharge energy / Wh kg"^-1 ~ "",
      En.c = "charge energy / Wh kg"^-1 ~ "",
      CE = expression("Q"[d] * " / Q"[c]),
      EE = expression("energy efficiency, E"[d] * " / E"[c]),
      meanE.d = "mean discharge voltage / V",
      meanE.c = "mean charge voltage / V")

#normalize by mass and convert units from Ah/mg to mAh/g
    data$Q.c<-data$Q.c/l$norm$mass*1e6
    data$Q.d<-data$Q.d/l$norm$mass*1e6
  }
    #set units for area normalization
    if (norm=="area" & !is.null(l$norm$area)){
      labels <- list(
        t = "time / s",
        step.n = "step number",
        cyc.n = "cycle number",
        I = "I / A",
        E = "cell voltage / V",
        Q.c = "Q charge / mAh cm"^-2 ~ "",
        Q.d = "Q discharge / mAh cm"^-2 ~ "",
        step.t = "step time / s",
        En.d = "discharge energy / mWh cm"^-2 ~ "",
        En.c = "charge energy / mWh cm"^-2 ~ "",
        CE = expression("Q"[d] * " / Q"[c]),
        EE = expression("energy efficiency, E"[d] * " / E"[c]),
        meanE.d = "mean discharge voltage / V",
        meanE.c = "mean charge voltage / V")

      #normalize by area and convert units from Ah/cm^2 to mAh/cm^2
      data$Q.c<-data$Q.c/l$norm$area*1000
      data$Q.d<-data$Q.d/l$norm$area*1000
    }
    #set units for volume normalization
    if (norm=="vol" & !is.null(l$norm$vol)){
      labels <- list(t = "time / s",
       step.n = "step number",
       cyc.n = "cycle number",
       I = "I / A",
       E = "cell voltage / V",
       Q.c = "Q charge / mAh cm"^-3 ~ "",
       Q.d = "Q discharge / mAh cm"^-3 ~ "",
       step.t = "step time / s",
       En.d = "discharge energy / Wh cm"^-3 ~ "",
       En.c = "charge energy / Wh cm"^-3 ~ "",
       CE = expression("Q"[d] * " / Q"[c]),
       EE = expression("energy efficiency, E"[d] * " / E"[c]),
       meanE.d = "mean discharge voltage / V",
       meanE.c = "mean charge voltage / V")

      #normalize by volume and convert units from Ah/cm^3 to mAh/cm^3
      data$Q.c<-data$Q.c/l$norm$vol*1000
      data$Q.d<-data$Q.d/l$norm$vol*1000
    }
  }
  #Provide error message if no normalization information is available for the value the user wants.
if (is.null(labels)){
  stop("This cell does not have the required normalization information. Please check that it was input correctly during import.")
}
  # Basic plot setup. ================================================
  p <- ggplot(data) + geom(aes_string(x = x, y = y), size = size)

  # Labels looked up from the list of labels. ========================
  p <- p + xlab(labels[[x]]) + ylab(labels[[y]])

  # If scales and grid are installed, then a custom theme is added.
  # This does not seem to work as I thought so it's cut out for now, and scales
  # and grid are required packages.
#  if(!requireNamespace("scales") == FALSE | !requireNamespace("grid") == FALSE) {
    p <- p + theme_bw() +
      theme(text = element_text(size=21)) +
      theme(panel.border = element_rect(size=1,color = "black")) +
      theme(axis.ticks.length=unit(-0.25, "cm")) +
      theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
      theme(axis.text.y = element_text(margin = margin(0, 0.5, 0, 0.2, "cm"))) +
      theme(panel.grid.major = element_line(size=0.5))

    # If the y-axis shows capacity, the plot is rescaled from 0 to max capacity.
    # Also requires the scales package.
    if(y %in% c("Q.c", "Q.d")) {
      p <- p + scale_y_continuous(limits=c(0, max(data[y])))
    }

#  }

  return(p)

}


#' arbin_plotvp
#'
#' This function takes a data frame of raw data and a specified cycle - or number
#' of cycles, as a vector - and outputs charge and discharge voltage profiles.
#' @param data The dataset, which is the list as outputted by arbin_import.
#' @param cycles The cycles to be plotted, expressed as a vector. Defaults to first cycle.
#' @param norm character string used to select how to normalize your data: "mass", "area", "vol". Deaults to Null and plots absolute capacity.
#' @keywords
#' @export
#' @examples
#' arbin_plotvp(mydataset, 1)
#' arbin_plotvp(mydataset, cycles = c(1,5,10), norm="mass")

arbin_plotvp <- function(data, cycles=1, norm=NULL)  {

  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)

  # Data for the specified cycles is filtered off (uses filter() from
  # the dplyr package.) Checks first what format the data is in. If it sees
  # a list it assumes it should use the 'raw' data frame.

  #Filter the data to remove I=0 data points and extra cycles.
  if (class(data) == "list") {
    plotted.data <- filter(data$raw, cyc.n %in% cycles, I != 0)
  } else if (class(data) == "data.frame") {
    plotted.data <- filter(data, cyc.n %in% cycles, I != 0)
  } else {
    stop("Data doesn't seem to be in a recognisable format! Was it imported with
         the arbin_import functions?")
  }

  # The function tries to guess whether the discharge or charge
  # step is first in the cycle. This affects correct plotting.
  for (i in unique(plotted.data$step.n)) {
    testI <- mean(plotted.data$I[plotted.data$step.n == i])

    if (testI == 0) {
    } else if (testI < 0) {
      plotted.data$Q.d[plotted.data$Q.c != 0] <- NA
      plotted.data$Q.c[plotted.data$Q.d != 0] <- NA
      break
    } else if (testI > 0) {
      plotted.data$Q.c[plotted.data$Q.d != 0] <- NA
      plotted.data$Q.d[plotted.data$Q.c != 0] <- NA
      break
    }
  }

  #Normalize capacity data=========================================
  #normalize capacity data according to desired norm variable for each cell.
  if (!is.null(norm))
  {
    #Perform mass normalization
    if (norm=="mass" & !is.null(data$norm$mass)){
    plotted.data$Q.d<-plotted.data$Q.d/data$norm$mass*1e6
    plotted.data$Q.c<-plotted.data$Q.c/data$norm$mass*1e6
    }
    #Perform area normalization
    if (norm=="area" & !is.null(data$norm$area)){
      plotted.data$Q.d<-plotted.data$Q.d/data$norm$area*1e3
      plotted.data$Q.c<-plotted.data$Q.c/data$norm$area*1e3
    }
    #Perform volume normalization
    if (norm=="vol" & !is.null(data$norm$vol)){
      plotted.data$Q.d<-plotted.data$Q.d/data$norm$vol*1e3
      plotted.data$Q.c<-plotted.data$Q.c/data$norm$vol*1e3
    }
  }

  #Set axis lables for each normalization case========================
  normunits<-NULL
  #set units for no normalization
  if (is.null(norm)){
    normunits <- xlab(expression("Q"[discharge] * " / mAh"))
  }
  if (!is.null(norm))
    #set units for mass normalization
  {if (norm=="mass" & !is.null(data$norm$mass)){
    normunits <- xlab(expression("Q"[discharge] * " / mAh g"^-1 ~ ""))
  }
    #set units for area normalization
    if (norm=="area" & !is.null(data$norm$area)){
      normunits <- xlab(expression("Q"[discharge] * " / mAh cm"^-2 ~ ""))
    }
    #set units for volume normalization
    if (norm=="vol" & !is.null(data$norm$vol)){
      normunits <- xlab(expression("Q"[discharge] * " / mAh cm"^-3 ~ ""))
    }
  }

  if (is.null(normunits)){
    stop("This cell does not have the required normalization information. Please check that it was input correctly during import.")
  }

  # Basic plot setup. =============================================
  p <- ggplot(plotted.data) +
    geom_path(aes(x = Q.d, y = E, color = factor(cyc.n), group = factor(cyc.n)), size = 1) +
    geom_path(aes(x = Q.c, y = E, color = factor(cyc.n), group = factor(cyc.n)), size = 1) +
    normunits +
    ylab("cell voltage / V") +
    guides(color = guide_legend(title = "cycle"))

  # If scales and grid are installed, then a custom theme is added.
  # This does not seem to work as I thought so it's cut out for now, and scales
  # and grid are required packages.
#  if (requireNamespace("scales", quietly = TRUE) & requireNamespace("grid", quietly = TRUE)) {
    p <- p + theme_bw() +
      theme(text = element_text(size=21)) +
      theme(panel.border = element_rect(size=1,color = "black")) +
      theme(axis.ticks.length=unit(-0.25, "cm")) +
      theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
      theme(axis.text.y = element_text(margin = margin(0, 0.5, 0, 0.2, "cm"))) +
      theme(panel.grid.major = element_line(size=0.5))
#  }

  return(p)

}

#' arbin_plotvp_multi
#'
#' Plot voltage vs capacity for multiple cells at one cycle. Used for rate capability
#' comparison and polarization comparison of multiple cells.
#'
#' @param list list containing list of data from multiple cells generated by arbinimport.
#' @param labels character vector containing the text to use for the plot legend. Must be as long as the number of cells being plotted
#' @param cycle The number of the cycle that is desired to be plotted. Default is cycle =1.
#' @param norm character string used to select how to normalize your data: "mass", "area", "vol". Defaults to Null.
#' @export
#' @examples
#' arbin_plotvp_multi(l1[1:3],c("test","test2","test3"),cycle=5)
arbin_plotvp_multi<-function (list, labels, cycle=1, norm=NULL)
{
  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)
  if (length(list) != length(labels)) {
    stop("Problem... it doesn't seem you've specified the same number of datasets as labels.")
  }

  #remove the statistics sublist, keep raw data for Q vs V plot
  stats <- lapply(list, function(x) x[[1]])

  #Step through each cell. Clean data for better plotting. Normalize data.
  stats <- lapply(seq_along(stats), function(i) {
    #give a warning message if not enough cycles in one cell.
    if (cycle>max(stats[[i]]$cyc.n)){
      warning("One cell doesn't have enough cycles to be included in this comparison. It will not be shown in the plot.")
    }
    df <- stats[[i]]
    #add column with label names to use for coloring plots.
    df$ident <- labels[i]
    #remove other cycles that you dont want.
    df<-filter(df, cyc.n == cycle, I!=0)
    #clean capacity data by setting to NA data that makes plots hard to read.
    for (i in unique(df$step.n)) {
      testI <- mean(df$I[df$step.n == i])
      if (testI == 0) {
      }
      else if (testI < 0) {
        df$Q.d[df$Q.c != 0] <- NA
        df$Q.c[df$Q.d != 0] <- NA
        break
      }
      else if (testI > 0) {
        df$Q.c[df$Q.d != 0] <- NA
        df$Q.d[df$Q.c != 0] <- NA
        break
      }
    }
    #normalize discharge capacity data according to desired norm variable for each cell.
    if (!is.null(norm))
    {if (norm=="mass" & !is.null(list[[i]]$norm$mass)){
      df$Q.d<-df$Q.d/list[[i]]$norm$mass*1e6
      df$Q.c<-df$Q.c/list[[i]]$norm$mass*1e6
    }
      #set units for area normalization
      if (norm=="area" & !is.null(list[[i]]$norm$area)){
        df$Q.d<-df$Q.d/list[[i]]$norm$area*1e3
        df$Q.c<-df$Q.c/list[[i]]$norm$area*1e3
      }
      #set units for volume normalization
      if (norm=="vol" & !is.null(list[[i]]$norm$vol)){
        df$Q.d<-df$Q.d/list[[i]]$norm$vol*1e3
        df$Q.c<-df$Q.c/list[[i]]$norm$vol*1e3
      }
    }
    return(df)
  })
  stats <- do.call(rbind, stats)

  #set units for no normalization
  normunits<-NULL
  if (is.null(norm)){
    normunits <- xlab(expression("Q"[discharge] * " / mAh"))
  }
  if (!is.null(norm))
    #set units for mass normalization
  {if (norm=="mass" & !is.null(l[[1]]$norm$mass)){
    normunits <- xlab(expression("Q"[discharge] * " / mAh g"^-1 ~ ""))
  }
    #set units for area normalization
    if (norm=="area" & !is.null(l[[1]]$norm$area)){
      normunits <- xlab(expression("Q"[discharge] * " / mAh cm"^-2 ~ ""))
    }
    #set units for volume normalization
    if (norm=="vol" & !is.null(l[[1]]$norm$vol)){
      normunits <- xlab(expression("Q"[discharge] * " / mAh cm"^-3 ~ ""))
    }
  }
  if (is.null(normunits)){
    stop("This cell does not have the required normalization information. Please check that it was input correctly during import.")
  }
  # Basic plot setup. ==========================================================
  p <- ggplot(stats) + geom_path(aes(x = Q.d, y = E, color = ident), size = 1)+
    geom_path(aes(x = Q.c, y = E, color = ident, group=ident), size = 1)+
    normunits + ylab("Voltage (V)") +
    guides(color = guide_legend("Cells"))

  # Plotting theme setup ==========================================================
  p <- p + theme_bw() + theme(text = element_text(size = 21)) + theme(legend.position = "bottom")+
    theme(panel.border = element_rect(size = 1, color = "black")) +
    theme(axis.ticks.length = unit(-0.25, "cm")) +
    theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
    theme(axis.text.y = element_text(margin = margin(0,0.5, 0, 0.2, "cm"))) +
    theme(panel.grid.major = element_line(size = 0.5))

  # Set y axis to continuous and set limits====================================
  p <- p + scale_y_continuous(limits = c(min(stats$E), max(stats$E)))
  return(p)
}

#' arbin_Qplot
#'
#' This function takes a list of datasets, a vector of labels for those datasets and
#' returns a formatted capacity vs cycle number plot.
#' @param list A list of datasets, as exported from the arbin_import function - so each
#' list element is also a list
#' @param labels A vector of labels corresponding to the datasets in the list, in the correct order.
#' @param norm character string used to select how to normalize your data: "mass", "area", "vol". Defaults to Null.
#' @keywords
#' @export
#' @examples
#' arbin_Qplot(list(mydatasetA, mydatasetB), labels = c("dataset A", "dataset B"))
#' arbin_Qplot(l1[1:3],labels=c("Cell1", "Cell2","Cell3"), norm="mass")

arbin_Qplot <- function(list, labels, norm=NULL)  {

  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)

  # Check that there are the same number of datasets as labels, and stop if not.
  if (length(list) != length(labels)) {
    stop("Problem... it doesn't seem you've specified the same number of datasets as labels.")
  }

  # Pull out the statistics from the datasets. =================================
  stats <- lapply(list, function(x) x[[2]])

  # Attach the label to the statistics. ========================================
  stats <- lapply(seq_along(stats), function(i) {
    df <- stats[[i]]
    #set ident for use in color coding the plot.
    df$ident <- labels[i]
    if (!is.null(norm))
    {#normalize discharge capacity data according to desired norm variable for each cell.
    if (norm=="mass" & !is.null(list[[i]]$norm$mass)){
      df$Q.d<-df$Q.d/list[[i]]$norm$mass*1e6
    }
      #set units for area normalization
      if (norm=="area" & !is.null(list[[i]]$norm$area)){
        df$Q.d<-df$Q.d/list[[i]]$norm$area*1e3
      }
      #set units for volume normalization
      if (norm=="vol" & !is.null(list[[i]]$norm$vol)){
        df$Q.d<-df$Q.d/list[[i]]$norm$vol*1e3
      }
    }
    return(df)
  })

  # Bind each statistics data frame into one data frame. =======================
  stats <- do.call(rbind, stats)

  #create axis label normunits for each normalization condition.=================
   #set units for no normalization
  normunits<-NULL
  if (is.null(norm)){
    normunits <- ylab(expression("Q"[discharge] * " / mAh"))
  }
  if (!is.null(norm))
    #set units for mass normalization
  {if (norm=="mass" & !is.null(l[[1]]$norm$mass)){
    normunits <- ylab(expression("Q"[discharge] * " / mAh g"^-1 ~ ""))
  }
    #set units for area normalization
    if (norm=="area" & !is.null(l[[1]]$norm$area)){
      normunits <- ylab(expression("Q"[discharge] * " / mAh cm"^-2 ~ ""))
    }
    #set units for volume normalization
    if (norm=="vol" & !is.null(l[[1]]$norm$vol)){
      normunits <- ylab(expression("Q"[discharge] * " / mAh cm"^-3 ~ ""))
    }
  }

  # Basic plot setup. ==========================================================
  if (is.null(normunits)){
    stop("Data for this normalization was missing upon import.")
  }
  p <- ggplot(stats) +
    geom_point(aes(x = cyc.n, y = Q.d, color = ident), size = 4) +
    xlab("cycle number") + normunits +
    guides(color = guide_legend(title = ""))

  # If scales and grid are installed, then a custom theme is added. y-axis is
  # also rescaled.
  # This does not seem to work as I thought so it's cut out for now, and scales
  # and grid are required packages.
#  if(!requireNamespace("scales") == FALSE | !requireNamespace("grid") == FALSE) {
    p <- p + theme_bw() +
      theme(text = element_text(size=21)) +
      theme(panel.border = element_rect(size=1,color = "black")) +
      theme(axis.ticks.length=unit(-0.25, "cm")) +
      theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
      theme(axis.text.y = element_text(margin = margin(0, 0.5, 0, 0.2, "cm"))) +
      theme(panel.grid.major = element_line(size=0.5))

    p <- p + scale_y_continuous(limits=c(0, max(stats$Q.d)))
#  }

  return(p)

}

#' arbin_dQdV
#'
#' Plot differential capacity plots (dQ/dV) for one cell at one cycle.
#'
#' @param list list of data generated from arbinimport script.
#' @param title input legend for the plot
#' @param cycle number of the cycle of interest, defaults to 1
#' @param ymin set ploting window range, defaults to 0.1
#' @param ymax set ploting window range, defaults to 1
#' @export
#' @examples
#' arbin_dQdV(list,cellfile,1,ymin,ymax)
arbin_dQdV<-function (list,title=NULL,cycle=1,ymin=-0.1,ymax=1)
{
  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)

  #remove the statistics sublist, keep raw data for dQ/dV vs V plot
  df <- list[1]

  #Combine discharge and charge capacity into continuous capacity Q.
  df$raw$Q<-df$raw$Q.c+df$raw$Q.d
  #Calculate dQ/dV
  x <- diff(df$raw$Q)/diff(df$raw$E)

  #Set non finite values to zero
  x[!is.finite(x)] <- 0

  #add zero to the beginning of the dQdV to recover the length of the vector after diff
  df$raw$dQdV<- c(0,x)
  df <- do.call(rbind, df)

  #remove other cycles than ones of interest.
  df<-filter(df, cyc.n == cycle)

  # Basic plot setup. ==========================================================
  p <- ggplot(df) + geom_point(aes(x = E, y = dQdV,color = factor(cyc.n), group = factor(cyc.n)),size = 1)+
  # Axis and legend titles set==================================================
    xlab(expression("Voltage / V")) + ylab("dQ/dV") +
    ggtitle(title)

  #Custom theme is added========================================================
  p <- p + theme_bw() + theme(text = element_text(size = 21)) + theme(legend.position = "bottom")+
    theme(panel.border = element_rect(size = 1, color = "black")) +
    theme(axis.ticks.length = unit(-0.25, "cm")) +
    theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
    theme(axis.text.y = element_text(margin = margin(0,0.5, 0, 0.2, "cm"))) +
    theme(panel.grid.major = element_line(size = 0.5))

  #Y axis is made to be continuous with limits set using ymin and ymax=========
  p <- p + scale_y_continuous(limits = c(ymin, ymax))
  return(p)
}

#' arbin_dQdV_multi
#'
#' Compare differential capacity plots from different cells, same cycle. .
#'
#' @param list list of data generated from arbinimport script.
#' @param label character vector containing the legend for each Cell for the legend
#' @param cycle Number of the cycle of interest, default is cycle=1
#' @param ymin set ploting window range for the dQ/dV axis, default is -1000
#' @param ymax set ploting window range for the dQ/dV axis, default is 1500
#' @export
#' @examples
#' arbin_dQdV_multi(l,title=c("Cell1", "Cell2","Cell3"),cycle=1,ymin=-1000,ymax=1500)
arbin_dQdV_multi<-function (list,label,cycle=1,ymin=-1,ymax=1)
{
  require(ggplot2)
  require(scales)
  require(grid)
  require(dplyr)

  #remove the statistics sublist, keep raw data for dQ/dV vs V plot
  stats <- lapply(list, function(x) x[[1]])
  stats <- lapply(seq_along(stats), function(i) {
    df<-stats[[i]]
    df$Q<-df$Q.c+df$Q.d
    x <- diff(df$Q)/diff(df$E)
    x[!is.finite(x)] <- 0
    df$dQdV<- c(0,x)
    #filter out/remove other cycles that you dont want.
    df<-filter(df, cyc.n %in% cycle)
    #add label to provide coloring for graphing
    df$label <- label[i]
    return(df)
  })
  stats <- do.call(rbind, stats)
  # Basic plot setup. ==========================================================
  p <- ggplot(stats) +
    geom_path(aes(x = E, y = dQdV, color=label), size=1)+

    # Axis and legend titles/colors set================================================
    xlab("Voltage (V)") + ylab("dQdV") +
    ggtitle(paste("Cycle",cycle))+
    labs(color="Sample")+

    #Custom theme is added========================================================
    theme_bw() +
    theme(text = element_text(size = 21)) +
    theme(legend.position = "right")+
    theme(panel.border = element_rect(size = 1, color = "black")) +
    theme(axis.ticks.length = unit(-0.25, "cm")) +
    theme(axis.text.x = element_text(margin = margin(0.5, 0, 0.2, 0, "cm"))) +
    theme(axis.text.y = element_text(margin = margin(0,0.5, 0, 0.2, "cm"))) +
    theme(panel.grid.major = element_line(size = 0.5))+

    #Y axis is made to be continuous with limits set using ymin and ymax=========
    scale_y_continuous(limits = c(ymin, ymax))
  return(p)
}

# Multiple plot function, coppied from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
#' Combine plots from many arbin plots into one for ease of report creation
#'
#' @param ... list of plot variables saved from an arbin plot function
#' @param labels character vector with the legends to use in the plots
#' @export
#' @examples
#' p1<-arbin_Qplot(l1[1:3],c("Cell1", "Cell2","Cell3"))
#' p2<-arbin_Qplot(l1[4:6],c("Cell4", "Cell5","Cell6"))
#' p3<-arbin_quickplot(l1[[1]],x="Q.d",y="E",norm="mass"))
#' multiplot(p1,p2,p3,cols=1)
#' multiplot(p1,p2,p3,cols=2)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
